/*
			Лабораторная №2
	Сдать до 23.02
Использовать команды сопроцессора.
Для реализации задания, использовать материалы на:

			Общее задание
1.	Использовать подпрограммы (вызов из  ассемблера функции на  C++)
2.	Использовать внешние подпрограммы (ассемблер в файле *.asm)


Индивидуальные задачи.

Функция представлена в виде своего ряда Тейлора. 
Вычислить приближённое значение суммы этого бесконечного ряда. 
Вычисления заканчивать, когда очередное слагаемое окажется по модулю 
меньше заданного числа eps. Сравнить полученный результат со значением,
вычисленным через стандартные функции, x и eps запросить у пользователя 
перед началом вычислений.

мой ряд: sqrt(1+x)

*/

#include <iostream>
#include <math.h>

using namespace std;

int main(void)
{
	setlocale(LC_ALL, "rus");
	
	
	double x; // начальное значение x
	double  eps; // точность

	double sum_const_cpp = 0; // sum по Тейлору

	double sum_const = 0;
	double sum_tailor = 0; // sum по Тейлору

	double term=1; // слагаемое 

//.................................................................
// забор данных
	cout << "Введите e и x: \n"; 
	cout << " eps (эпсилон) > 0 и < 1 = "; // точность e
	cin >> eps;
	while (eps < 0)
	{
		cout << "\ni должно быть больше 0" << endl;
		cout << "Введите точность eps = ";
		cin >> eps;
	}
	cout << "\nЧисло (x < 1 и x > -1) x = "; // число x
	cin >> x;
	while (x < -1 || x > 1)
	{
		cout << "x должен быть (x > -1) и (x < 1)" << endl;
		cout << "enter x = ";
		cin >> x;
	}

//.................................................................
	double a = x/2;
	sum_tailor = 1 + x / 2;
	int i = 2;
	sum_const_cpp = sqrt(1 + x);

	double minus_one = -1.0;
	double tree = 3.0;
	int two = 2.0;
	double one = 1.0;
	int three = 3.0;
	double y = 0;
	int aaaa = 0;

	__asm
	{
		finit // приведение сопроцессора в начальное состояние
	loop_1:
		fld a
		mov eax, i // (то что в скобках)
		mov ebx, 2
		mul ebx
		mov ebx, 3 
		sub eax, ebx
		mov aaaa, eax
		fld aaaa
		fmul
		fld x // загружаем значиние x
		fmul
		fld minus_one
		fmul 
		fld two
		fdiv
		fld i
		fdiv
		fld a 
		fmul
		fst a // копирует результат в a, FSTP полностью выталкивает число
		fabs // берем модуль
		fld eps
		fcompp // сравниваем 1 число из стека и esp и выталкивает число из стека
		jc hi_1 // если st(0) больше
		jnc hi_2 // если st(0) меньше

	hi_1:
		// сейчас в стеке пусто
		fld a
		fld sum_tailor
		fadd
		fstp sum_tailor // сохранение вещественного числа из вершины стека сопроцессора в память.
		inc i // добавить 1 к i
		jmp loop_1

	hi_2:
		fld x
		fld one
		fadd
		fsqrt
		fstp sum_const
	}

	//while (abs(a = a * (-1) * x * (2 * i - 3) / (2 * i) ) > eps)
	//{
	//	sum_tailor += a;
	//	i++;
	//}

//.................................................................
// вывод
	printf("Ответ через sqrt_cpp \t= " "%10.15f\n", sum_const_cpp);
	printf("Ответ через Тейлора \t= " "%10.15f\n", sum_tailor);
	printf("Ответ через sqrt_asm \t= %10.15f\n", sum_const);
	return 0;
//.................................................................
} 

